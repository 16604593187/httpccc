### CMakeLists.txt的编写：

#### 首先是cmake的版本指定，项目名称的指定与使用语言，以及C++版本号的指定

```cmake
cmake_minimum_required(VERSION X.XX)
project(Projectname VERSION X.X.X LANGUAGE CXX)
set(CMAKE_CXX_STANDARD XX)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

#### 接着是目标定义构建

##### 1.源文件列表：

使用set语句（仅需加入cpp文件）

```cmake
set(MY_PROJECT_SOURCE_NAME#MY_PROJECT_SOURCE_NAME是由自己定义的用于存放源文件路径列表的cmake变量
    文件名
    文件名
    ...)
```

##### 2.添加目标：

```cmake
add_executable(MyProjectExec ${MY_PROJECT_SOURCE_NAME})#MyProjectExec是想要生成的可执行文件名，由自己定义
```

##### DAY1(2025.9.29)

接下来是基础框架的搭建：

首先对CMakeLists与文件目录进行更新

```cmake
#基础设置部分
cmake_minimum_required(VERSION 3.15)
project(httpccc VERSION 0.1.0 LANGUAGE CXX)
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
#目标定义构建部分
set(MY_PROJECT_SOURCE
    src/main.cpp
    src/socket.cpp)
add_executable(MyProjectExec ${MY_PROJECT_SOURCE})
target_include_directories(MyProjectExec
    PRIVATE
        ${CMAKE_SOURCE_DIR}/include)
```

添加了include文件夹(socket.h)，src文件夹(main.cpp, socket.cpp)

socket.h文件的编写，定义socket的创建，绑定与监听：

```cpp
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<string>
#include<cstdint>
class Socket{
private:
    int _sockfd;//socket文件描述符
    sockaddr_in _serv_addr;//存储IP地址，端口号，地址簇等信息
public:
    Socket();//调用socket系统调用，创建socket描述符
    ~Socket();//析构函数
    void bind(const std::string& ip,uint16_t port);//配置服务器地址结构，调用bind()系统调用
    void listen(int backlog);//监听
    int fd()const;
};
```

socket.cpp的编写：

1.socket()的实现：

首先是socket的创建与错误审查：

```cpp
Socket::Socket(){//调用socket()系统调用，创建成员
    if((_sockfd=socket(AF_INET,SOCK_STREAM,0))==-1){//错误审查，如果返回值为-1，则发出错误报告，返回异常
        std::string error_msg = "Socket creation failed: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }

```

这里直接将创建与错误审查合为一处，让代码更简洁。

2.bind()的实现：

先在socket.h中对sockaddr_in _serv_addr;进行零初始化

```c++
sockaddr_in _serv_addr{};
```

随后在bind()中进行编写。

1).对所有信息进行初始化

```cpp
memset(&_serv_addr,0,sizeof(_serv_addr));//使用memset进行零初始化，所传入的三个参数分别是要初始化的内存地址，初始化成的值，初始化的字节数
```

2).设置地址簇

```cpp
_serv_addr.sin_family=AF_INET;//设置IPV4地址簇
```

3).设置特定ip地址并进行错误检查

```cpp
if((inet_pton(AF_INET,ip.c_str(),&_serv_addr.sin_addr.s_addr))<=0){//设置ip地址
        if(errno==0)throw std::runtime_error("Bind failed: Invalid IP address format.");
        else{
            std::string error_msg = "Bind failed: inet_pton system error: " + std::string(strerror(errno));
            throw std::runtime_error(error_msg);
        }
    }
```

4).设置端口号，调用系统bind()并进行错误检查

```cpp
	_serv_addr.sin_port=htons(port);
    if(::bind(_sockfd,(struct sockaddr *)&_serv_addr,sizeof(_serv_addr))==-1){//调用系统bind()并做错误检查
        std::string error_msg = "Socket bind failed!" + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
```

3.listen()的实现：

```cpp
void Socket::listen(int backlog){
    if((::listen(_sockfd,backlog))==-1){//调用系统调用listen进行监听
        std::string error_msg = "Listen failed!" + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
}
```

4.析构函数~Socket()的实现：

```cpp
Socket::~Socket(){
    if(_sockfd>=0){
        if(::close(_sockfd)==-1){
        std::string error_msg = "Close failed!" + std::string(strerror(errno));
        }
        _sockfd=-1;
    }
}
```

最后，将Socket()构造函数进行优化，加入端口复用和非阻塞状态设置，保证其能容纳后续epoll等功能的添加。

1.非阻塞状态设置：使用fcntl系统函数获取状态标志，随后将其处理成非阻塞状态标志

```cpp
int vatc;//非阻塞状态设置
    if((vatc=::fcntl(_sockfd, F_GETFL))==-1){
        std::string error_msg = "标志获取失败: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
    vatc|=O_NONBLOCK;
```

然后再使用fcntl系统函数修改回去

```cpp
if(fcntl(_sockfd, F_SETFL, vatc)==-1){
        std::string error_msg = "非阻塞状态设置失败: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
```

2.端口复用设置：使用setsockopt函数

```cpp
	int opt_val=1;
    if(setsockopt(_sockfd, SOL_SOCKET, SO_REUSEADDR, &opt_val, sizeof(opt_val))==-1){//端口复用设置
        std::string error_msg = "SO_REUSEADDR setting failed: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
```

#### git本地仓库创建与github上线

1.git本地仓库创建：

1）git仓库初始化

```bash
git init
```

2）创建gitignore文件

```bash
nano .gitignore
```

3）输入内容

```
# 忽略 CMake 生成的构建目录
/build/
/CMakeFiles/
CMakeCache.txt
cmake_install.cmake

# 忽略可执行文件和目标文件
*.o
*.so
*.a
httpccc # 你的可执行文件名

# 忽略 IDE 和编辑器文件 (根据你的环境)
.vscode/
.idea/
*.swp
```

4）文件更新

```cpp
git add .
```

5.)输入信息

```bash
git config --global user.email " "
git config --global user.name " "
```

6）提交

```cpp
git commit -m " "
```

2.github上线

创建github仓库，关联本地仓库

```bash
git remote add origin <URL>
```

重命名分支

```bash
git branch -M main
```

上线

```bash
git push -u origin main（初次上线）
git push origin main（后续）
```



