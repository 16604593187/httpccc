### CMakeLists.txt的编写：

#### 首先是cmake的版本指定，项目名称的指定与使用语言，以及C++版本号的指定

```cmake
cmake_minimum_required(VERSION X.XX)
project(Projectname VERSION X.X.X LANGUAGE CXX)
set(CMAKE_CXX_STANDARD XX)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

#### 接着是目标定义构建

##### 1.源文件列表：

使用set语句（仅需加入cpp文件）

```cmake
set(MY_PROJECT_SOURCE_NAME#MY_PROJECT_SOURCE_NAME是由自己定义的用于存放源文件路径列表的cmake变量
    文件名
    文件名
    ...)
```

##### 2.添加目标：

```cmake
add_executable(MyProjectExec ${MY_PROJECT_SOURCE_NAME})#MyProjectExec是想要生成的可执行文件名，由自己定义
```

#### DAY1(2025.9.29)

接下来是基础框架的搭建：

首先对CMakeLists与文件目录进行更新

```cmake
#基础设置部分
cmake_minimum_required(VERSION 3.15)
project(httpccc VERSION 0.1.0 LANGUAGE CXX)
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
#目标定义构建部分
set(MY_PROJECT_SOURCE
    src/main.cpp
    src/socket.cpp)
add_executable(MyProjectExec ${MY_PROJECT_SOURCE})
target_include_directories(MyProjectExec
    PRIVATE
        ${CMAKE_SOURCE_DIR}/include)
```

添加了include文件夹(socket.h)，src文件夹(main.cpp, socket.cpp)

socket.h文件的编写，定义socket的创建，绑定与监听：

```cpp
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<string>
#include<cstdint>
class Socket{
private:
    int _sockfd;//socket文件描述符
    sockaddr_in _serv_addr;//存储IP地址，端口号，地址簇等信息
public:
    Socket();//调用socket系统调用，创建socket描述符
    ~Socket();//析构函数
    void bind(const std::string& ip,uint16_t port);//配置服务器地址结构，调用bind()系统调用
    void listen(int backlog);//监听
    int fd()const;
};
```

socket.cpp的编写：

1.socket()的实现：

首先是socket的创建与错误审查：

```cpp
Socket::Socket(){//调用socket()系统调用，创建成员
    if((_sockfd=socket(AF_INET,SOCK_STREAM,0))==-1){//错误审查，如果返回值为-1，则发出错误报告，返回异常
        std::string error_msg = "Socket creation failed: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }

```

这里直接将创建与错误审查合为一处，让代码更简洁。

2.bind()的实现：

先在socket.h中对sockaddr_in _serv_addr;进行零初始化

```c++
sockaddr_in _serv_addr{};
```

随后在bind()中进行编写。

1).对所有信息进行初始化

```cpp
memset(&_serv_addr,0,sizeof(_serv_addr));//使用memset进行零初始化，所传入的三个参数分别是要初始化的内存地址，初始化成的值，初始化的字节数
```

2).设置地址簇

```cpp
_serv_addr.sin_family=AF_INET;//设置IPV4地址簇
```

3).设置特定ip地址并进行错误检查

```cpp
if((inet_pton(AF_INET,ip.c_str(),&_serv_addr.sin_addr.s_addr))<=0){//设置ip地址
        if(errno==0)throw std::runtime_error("Bind failed: Invalid IP address format.");
        else{
            std::string error_msg = "Bind failed: inet_pton system error: " + std::string(strerror(errno));
            throw std::runtime_error(error_msg);
        }
    }
```

4).设置端口号，调用系统bind()并进行错误检查

```cpp
	_serv_addr.sin_port=htons(port);
    if(::bind(_sockfd,(struct sockaddr *)&_serv_addr,sizeof(_serv_addr))==-1){//调用系统bind()并做错误检查
        std::string error_msg = "Socket bind failed!" + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
```

3.listen()的实现：

```cpp
void Socket::listen(int backlog){
    if((::listen(_sockfd,backlog))==-1){//调用系统调用listen进行监听
        std::string error_msg = "Listen failed!" + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
}
```

4.析构函数~Socket()的实现：

```cpp
Socket::~Socket(){
    if(_sockfd>=0){
        if(::close(_sockfd)==-1){
        std::string error_msg = "Close failed!" + std::string(strerror(errno));
        }
        _sockfd=-1;
    }
}
```

最后，将Socket()构造函数进行优化，加入端口复用和非阻塞状态设置，保证其能容纳后续epoll等功能的添加。

1.非阻塞状态设置：使用fcntl系统函数获取状态标志，随后将其处理成非阻塞状态标志

```cpp
int vatc;//非阻塞状态设置
    if((vatc=::fcntl(_sockfd, F_GETFL))==-1){
        std::string error_msg = "标志获取失败: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
    vatc|=O_NONBLOCK;
```

然后再使用fcntl系统函数修改回去

```cpp
if(fcntl(_sockfd, F_SETFL, vatc)==-1){
        std::string error_msg = "非阻塞状态设置失败: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
```

2.端口复用设置：使用setsockopt函数

```cpp
	int opt_val=1;
    if(setsockopt(_sockfd, SOL_SOCKET, SO_REUSEADDR, &opt_val, sizeof(opt_val))==-1){//端口复用设置
        std::string error_msg = "SO_REUSEADDR setting failed: " + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
```

#### git本地仓库创建与github上线

1.git本地仓库创建：

1）git仓库初始化

```bash
git init
```

2）创建gitignore文件

```bash
nano .gitignore
```

3）输入内容

```
# 忽略 CMake 生成的构建目录
/build/
/CMakeFiles/
CMakeCache.txt
cmake_install.cmake

# 忽略可执行文件和目标文件
*.o
*.so
*.a
httpccc # 你的可执行文件名

# 忽略 IDE 和编辑器文件 (根据你的环境)
.vscode/
.idea/
*.swp
```

4）文件更新

```cpp
git add .
```

5.)输入信息

```bash
git config --global user.email " "
git config --global user.name " "
```

6）提交

```cpp
git commit -m " "
```

2.github上线

创建github仓库，关联本地仓库

```bash
git remote add origin <URL>
```

重命名分支

```bash
git branch -M main
```

上线

```bash
git push -u origin main（初次上线）
git push origin main（后续）
```

#### DAY2(2025.9.30)

新增了epoll事件循环

1.添加了epoll.h:

```cpp
#include<sys/epoll.h>
#include<unistd.h>
#include<vector>
class Epoll{
private:
    int _epollfd=-1;//存储epoll实例的文件描述符
    std::vector<epoll_event> _events;//存储epoll的就绪事件数组
    static const int MAX_EVENTS=1024;
public:
    Epoll();
    ~Epoll();
    void add_fd(int fd,uint32_t events);//将socket注册到epoll实例中
    int wait(int timeout_ms=-1);//返回等待确认的事件个数
    const std::vector<epoll_event>& get_events() const { return _events; }
};
```

2.添加epoll.cpp文件，更新CMakeLists，实现功能函数。

1）实现Epoll构造函数

使用epoll_create1(0)初始化事件数组并分配空间。

```cpp
Epoll::Epoll(){
    if((_epollfd=epoll_create1(0))==-1){//初始化事件数组
        std::string error_msg = "Epoll creation failed:" + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
    _events.resize(MAX_EVENTS);//分配空间并检查
    if(_events.empty()&&MAX_EVENTS>0){
        throw std::runtime_error("Epoll event vector initialization failed.");
    }
}
```

2）实现~epoll析构函数。

```cpp
Epoll::~Epoll(){
    if(_epollfd>=0){
        if(::close(_epollfd)==-1){
            std::string error_msg = "Epoll close failed:" + std::string(strerror(errno));
            std::cerr << error_msg << std::endl; 
        }
        _epollfd=-1;
    }
}
```

3）实现add_fd函数。

创建epoll_event结构体，并且设置events和data.fd，调用::epoll_ctl系统函数将socket fd添加到epoll监控列表。

```cpp
void Epoll::add_fd(int fd,uint32_t events){
    epoll_event event;//创建epoll_event结构体
    memset(&event,0,sizeof(event));//初始化event和data.fd
    event.events=events;
    event.data.fd=fd;
    if(::epoll_ctl(_epollfd, EPOLL_CTL_ADD, fd, &event)==-1){//将socket fd添加到epoll监控列表
        std::string error_msg = "Epoll add_fd failed:" + std::string(strerror(errno));
        throw std::runtime_error(error_msg);
    }
}
```

4）实现wait函数

进入epoll循环，调用::epoll_wait系统函数阻塞等待事件，错误处理：当发生错误时，先检查其是否为中断事件，如果是中断事件，那么运行没有问题，直接continue。

```cpp
int Epoll::wait(int timeout_ms){
    int num_events;
    if(_epollfd<0)throw std::runtime_error("Epoll instance is not valid.");
    while(true){
        num_events=::epoll_wait(_epollfd, _events.data(), MAX_EVENTS, timeout_ms);
        if(num_events==-1){
            if(errno==EINTR)continue;//如果是中断事件直接continue
            else{
                std::string error_msg = "Epoll wait failed: " + std::string(strerror(errno));
                throw std::runtime_error(error_msg);
            }

        }
        break;
    }
    return num_events;
}
```

3.更新socket.h和socket.cpp新增accept函数，用于接受新的客户端连接。

socket.h

```cpp
int accept(struct sockaddr_in& client_addr);
```

socket.cpp

先初始化地址结构，随后调用::accept系统函数接受新的客户端，错误处理：当accept没有立即找到新的连接时，它会设置errno为EAGAIN或EWOLDBLOCK，但是这在epoll循环中不是异常，所以返回-1，让主循环继续。

```cpp
int Socket::accept(struct sockaddr_in& client_addr){
    memset(&client_addr,0,sizeof(client_addr));//初始化地址结构，即其值与长度
    socklen_t addr_len=sizeof(client_addr);
    int client_fd;
    if((client_fd=::accept(_sockfd, (struct sockaddr *)&client_addr, &addr_len))==-1){
        if(errno==EAGAIN||errno==EWOULDBLOCK){
            return -1;
        }else{
            std::string error_msg = "Accept failed:" + std::string(strerror(errno));
            throw std::runtime_error(error_msg);
        }
    }
    return client_fd;
}
```



